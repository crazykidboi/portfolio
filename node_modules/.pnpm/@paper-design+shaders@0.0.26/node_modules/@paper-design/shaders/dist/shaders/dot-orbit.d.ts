export type DotOrbitUniforms = {
    u_scale: number;
    u_color1: [number, number, number, number];
    u_color2: [number, number, number, number];
    u_color3: [number, number, number, number];
    u_color4: [number, number, number, number];
    u_dotSize: number;
    u_dotSizeRange: number;
    u_spreading: number;
};
/**
 * Dot Pattern with dot moving around their grid position
 * The artwork by Ksenia Kondrashova
 * Renders a dot pattern with dot placed in the center of each cell of animated Voronoi diagram
 *
 * Uniforms include:
 * u_scale - the scale applied to user space
 * u_color1 - the first color
 * u_color2 - the second color
 * u_color3 - the third color
 * u_color4 - the fourth color
 * u_dotSize (0 .. 1) - the base dot radius (relative to cell size)
 * u_dotSizeRange (0 .. 1) - the dot radius to vary between the cells
 * u_spreading (0 .. 1) - the distance each dot can move around the regular grid
 */
export declare const dotOrbitFragmentShader = "#version 300 es\nprecision highp float;\n\nuniform float u_time;\nuniform float u_pixelRatio;\nuniform vec2 u_resolution;\n\nuniform float u_scale;\nuniform vec4 u_color1;\nuniform vec4 u_color2;\nuniform vec4 u_color3;\nuniform vec4 u_color4;\nuniform float u_dotSize;\nuniform float u_dotSizeRange;\nuniform float u_spreading;\n\nout vec4 fragColor;\n\n#define TWO_PI 6.28318530718\n\nfloat random(in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\nvec2 random2(vec2 p) {\n  return vec2(random(p), random(200. * p));\n}\n\nvec3 get_voronoi_shape(vec2 _uv, float time) {\n  vec2 i_uv = floor(_uv);\n  vec2 f_uv = fract(_uv);\n\n  float min_dist = 1.;\n  vec2 cell_randomizer = vec2(0.);\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 tile_offset = vec2(float(x), float(y));\n      vec2 rand = random2(i_uv + tile_offset);\n      vec2 cell_center = .5 + 1e-4 + .25 * clamp(u_spreading, 0., 1.) * sin(time + TWO_PI * rand);\n      float dist = length(tile_offset + cell_center - f_uv);\n      if (dist < min_dist) {\n        min_dist = dist;\n        cell_randomizer = rand;\n      }\n      min_dist = min(min_dist, dist);\n    }\n  }\n\n  return vec3(min_dist, cell_randomizer);\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n\n  uv -= .5;\n  float scale = .5 * u_scale + 1e-4;\n  uv *= (.02 * (1. - step(1. - scale, 1.) / scale));\n  uv *= u_resolution;\n  uv /= u_pixelRatio;\n  uv += .5;\n\n  float t = u_time;\n\n  vec3 voronoi = get_voronoi_shape(uv, t) + 1e-4;\n\n  float radius = .25 * clamp(u_dotSize, 0., 1.) - .5 * clamp(u_dotSizeRange, 0., 1.) * voronoi[2];\n  float dist = voronoi[0];\n  float edge_width = fwidth(dist);\n  float shape = smoothstep(radius + edge_width, radius - edge_width, dist);\n\n  float color_randomizer = voronoi[1];\n\n  float opacity =\n    u_color1.a * step(0.0, color_randomizer) * step(color_randomizer, 0.25) +\n    u_color2.a * step(0.25, color_randomizer) * step(color_randomizer, 0.5) +\n    u_color3.a * step(0.5, color_randomizer) * step(color_randomizer, 0.75) +\n    u_color4.a * step(0.75, color_randomizer) * step(color_randomizer, 1.0);\n\n  opacity *= shape;\n\n  vec3 color =\n    u_color1.rgb * step(0.0, color_randomizer) * step(color_randomizer, 0.25) +\n    u_color2.rgb * step(0.25, color_randomizer) * step(color_randomizer, 0.5) +\n    u_color3.rgb * step(0.5, color_randomizer) * step(color_randomizer, 0.75) +\n    u_color4.rgb * step(0.75, color_randomizer) * step(color_randomizer, 1.0);\n\n  fragColor = vec4(color * opacity, opacity);\n}\n";
