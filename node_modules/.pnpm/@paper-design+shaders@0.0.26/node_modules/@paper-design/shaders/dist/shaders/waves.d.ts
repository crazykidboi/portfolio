export type WavesUniforms = {
    u_scale: number;
    u_rotation: number;
    u_color: [number, number, number, number];
    u_shape: number;
    u_frequency: number;
    u_amplitude: number;
    u_spacing: number;
    u_dutyCycle: number;
    u_softness: number;
};
/**
 * Waves static pattern on the transparent background
 *
 * Uniforms include:
 * u_scale - the scale applied to user space
 * u_rotation - the rotation applied to user space
 * u_color - the wave color
 * u_shape (0 ... 3) - the line shaping coefficient, non-integer
   values allowed and produce mixed shapes
   - u_shape = 0 is zigzag
   - u_shape = 1 is perfect sine wave
   - u_shape = 2 is irregular wave #1
   - u_shape = 3 is irregular wave #2
 * u_frequency - the wave frequency
 * u_amplitude - the wave amplitude
 * u_spacing - the density of pattern lines
 * u_dutyCycle (0 ... 1) - the proportion of stroke width to the pattern step
 * u_softness (0 ... 1) - the blur applied to the lines edges
 */
export declare const wavesFragmentShader = "#version 300 es\nprecision highp float;\n\nuniform float u_pixelRatio;\nuniform vec2 u_resolution;\n\nuniform float u_scale;\nuniform float u_rotation;\n\nuniform vec4 u_color;\nuniform float u_shape;\nuniform float u_frequency;\nuniform float u_amplitude;\nuniform float u_spacing;\nuniform float u_dutyCycle;\nuniform float u_softness;\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n\nout vec4 fragColor;\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n\n  uv -= .5;\n  uv *= (.02 * max(0., u_scale) * u_resolution);\n  uv = rotate(uv, u_rotation * .5 * PI);\n  uv /= u_pixelRatio;\n  uv += .5;\n\n  float wave = .5 * cos(uv.x * u_frequency * TWO_PI);\n  float zigzag = 2. * abs(fract(uv.x * u_frequency) - .5);\n  float irregular = sin(uv.x * .25 * u_frequency * TWO_PI) * cos(uv.x * u_frequency * TWO_PI);\n  float irregular2 = .75 * (sin(uv.x * u_frequency * TWO_PI) + .5 * cos(uv.x * .5 * u_frequency * TWO_PI));\n\n  float offset = mix(zigzag, wave, smoothstep(0., 1., u_shape));\n  offset = mix(offset, irregular, smoothstep(1., 2., u_shape));\n  offset = mix(offset, irregular2, smoothstep(2., 3., u_shape));\n  offset *= 2. * u_amplitude;\n  \n  float spacing = .02 + .98 * u_spacing;\n  float shape = .5 + .5 * sin((uv.y + offset) * PI / spacing);\n  \n  float edge_width = .02 / (1. + abs(shape)) * (.001 + u_scale);\n  edge_width += .5 * max(0., u_softness);\n  float dc = clamp(1. - u_dutyCycle, 0., 1.);\n  float s = smoothstep(dc - edge_width, dc + edge_width, shape);\n\n  vec3 color = u_color.rgb * u_color.a * s;\n  float opacity = u_color.a * s;\n  \n  fragColor = vec4(color, opacity);\n}\n";
