/** Uniform types that we support to be auto-mapped into the fragment shader */
export type ShaderMountUniforms = Record<string, number | number[] | HTMLImageElement>;
/** A canvas element that has a ShaderMount available on it */
export interface PaperShaderDivWrapperElement extends HTMLDivElement {
    paperShaderMount: ShaderMount | undefined;
}
/** Check if a canvas element is a ShaderCanvas */
export declare function isPaperShaderDivWrapper(div: HTMLDivElement): div is PaperShaderDivWrapperElement;
export declare class ShaderMount {
    mountToDiv: PaperShaderDivWrapperElement;
    canvas: HTMLCanvasElement;
    private gl;
    private program;
    private uniformLocations;
    /** The fragment shader that we are using */
    private fragmentShader;
    /** Stores the RAF for the render loop */
    private rafId;
    /** Time of the last rendered frame */
    private lastRenderTime;
    /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */
    private totalFrameTime;
    /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */
    private speed;
    /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */
    private providedUniforms;
    /** Just a sanity check to make sure frames don't run after we're disposed */
    private hasBeenDisposed;
    /** If the resolution of the canvas has changed since the last render */
    private resolutionChanged;
    /** Store textures that are provided by the user */
    private textures;
    /** The maximum resolution (on the larger axis) that we render for the shader, to protect against insane resolutions and bad performance. Actual CSS size of the canvas can be larger, it will just lose quality after this */
    private maxResolution;
    constructor(
    /** The div you'd like to mount the shader to. The shader will match its size. */
    mountToDiv: HTMLDivElement, fragmentShader: string, uniforms?: ShaderMountUniforms, webGlContextAttributes?: WebGLContextAttributes, 
    /** The speed of the animation, or 0 to stop it. Supports negative values to play in reverse. */
    speed?: number, 
    /** Pass a frame to offset the starting u_time value and give deterministic results*/
    frame?: number, 
    /** The maximum resolution (on the larger axis) that we render for the shader. Use virtual pixels, will be multiplied by display DPI to get the actual resolution. Actual CSS size of the canvas can be larger, it will just lose quality after this */
    maxResolution?: number);
    private initProgram;
    private setupPositionAttribute;
    private setupUniforms;
    private resizeObserver;
    private setupResizeObserver;
    /** The scale that we should render at (prevents the virtual resolution from going beyond our maxium and then multiplies by pixelRatio (at least 2X rendering always) */
    private renderScale;
    /** Resize handler for when the container div changes size and we want to resize our canvas to match */
    private handleResize;
    private render;
    private requestRender;
    /** Creates a texture from an image and sets it into a uniform value */
    private setTextureUniform;
    /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */
    private setUniformValues;
    /** Gets the current total animation time from 0ms */
    getCurrentFrameTime: () => number;
    /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */
    setFrame: (newFrame: number) => void;
    /** Set an animation speed (or 0 to stop animation) */
    setSpeed: (newSpeed?: number) => void;
    /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */
    setUniforms: (newUniforms: ShaderMountUniforms) => void;
    /** Dispose of the shader mount, cleaning up all of the WebGL resources */
    dispose: () => void;
}
